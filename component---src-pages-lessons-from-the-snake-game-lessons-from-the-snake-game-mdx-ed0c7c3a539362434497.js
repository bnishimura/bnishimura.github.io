"use strict";(self.webpackChunkgatsby_starter_default=self.webpackChunkgatsby_starter_default||[]).push([[99],{4881:function(e,t,a){a.r(t),a.d(t,{_frontmatter:function(){return r},default:function(){return c}});var n=a(3366),o=(a(7294),a(4983)),s=a(7359),i=["components"],r={title:"Lessons from the snake game",path:"/lessons-from-the-snake-game",date:"2022-05-12",tags:["JavaScript","React"],excerpt:"I've made one of those old snake games using React as a first step to learn the framework and ended up learning a lot about React and its particularities. Here I will try to condense this knowledge."},l={_frontmatter:r};function c(e){var t=e.components,a=(0,n.Z)(e,i);return(0,o.mdx)("wrapper",Object.assign({},l,a,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("p",null,"I","'","ve made onde of those old snake games as a first step to learn React:"),(0,o.mdx)("div",{className:"blog-post-content",style:{display:"flex",justifyContent:"center"}},(0,o.mdx)(s.default,{mdxType:"SnakeGame"})),(0,o.mdx)("p",null,"The code for the game can be found ",(0,o.mdx)("a",{parentName:"p",href:"https://github.com/bnishimura/NishiWare/blob/main/src/pages/lessons-from-the-snake-game/snake.js"},"here"),"."),(0,o.mdx)("p",null,"It turns out React is not really a nice and clean way to make a game and the reason for this is mainly\nbecause of React","'","s execution flow. Compared to simply updating a canvas with JavaScript, React seems like a\nconvoluted solution that brings about a lot of complications. But none of this matters since the goal is to\ngrok the framework. "),(0,o.mdx)("p",null,"There is not really much to talk about in terms of game logic, after all this part of the code is actually\nsimple JS. The problem lies in the integration between React and the game logic and that","'","s what I will explore\nin this article."),(0,o.mdx)("h1",null,"The main hurdle: constant frame rate"),(0,o.mdx)("hr",null),(0,o.mdx)("p",null,"This might seem simple to solve at first: we can use the timer methods (like ",(0,o.mdx)("inlineCode",{parentName:"p"},"setInterval()")," or ",(0,o.mdx)("inlineCode",{parentName:"p"},"setTimeout()"),")\nfrom the web APIs to call a game loop that handles the game state at each frame. But then, when you try to play\nthe game, the canvas does not change even though your timer is getting called at the specified interval."),(0,o.mdx)("p",null,"The issue in this case is that React seems to, for each render, create a new object that represents the component,\nwith each object carrying the state of the render as a static value. In other words, calling\n",(0,o.mdx)("inlineCode",{parentName:"p"},"setInterval(gameLoop, 1000/FRAME_RATE)")," will call the gameLoop of the first render FRAME_RATE times per second.\nSince each render is a different object and each object has its own scope, carrying a React state that is not\nmutable from within the object, gameLoop does not change. Thats the gist of it, now I shall elaborate each point\nand outline a solution for it."),(0,o.mdx)("h2",null,"React states"),(0,o.mdx)("p",null,"Consider the hook:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"const [count, setCount] = useState(0);\n")),(0,o.mdx)("p",null,"Every time the setter setCount is called, React calls the component. This component call is, at least in effect,\nthe creation of a new component, but this time with a new, hard coded value you fed to the setter. This means\nReact states inside each generated component are not supposed to be mutated ","–"," in fact, it is impossible\nto do so (count in the example is constant, you cannot assign to it directly). Therefore, each render is\nrepresented by a different instance of the component."),(0,o.mdx)("p",null,"So what causes the setInterval issue? Because each render is related to an instance of the game","'","s\nreact component, and a different gameLoop belongs to each instance, there will always be a static React\nstate inside any given gameLoop","'","s scope. Therefore setInterval is using a gameLoop that can only\nsee the same ","–"," immutable ","–"," values (in other words, gameLoop","'","s scope does not change)."),(0,o.mdx)("h2",null,"Solution"),(0,o.mdx)("p",null,"The solution is to use a reference:"),(0,o.mdx)("pre",null,(0,o.mdx)("code",{parentName:"pre"},"const callback = useRef();\nconst timer = useRef();\nuseEffect(() => {\n    callback.current = gameLoop;\n    function tick() {\n        callback.current();\n    }\n    timer.current = setInterval(tick, 1000/FRAME_RATE);\n});\n")),(0,o.mdx)("p",null,"With the extra layer of indirection provided by the ref, we can pass the gameLoop of the current instance of the\ncomponent. But doing something like ",(0,o.mdx)("inlineCode",{parentName:"p"},"setInterval(callback.current, 1000/FRAME_RATE)")," gives us the same problem,\nmost likely because refs behave similarly to states (meaning they probably are instance-wise static).\nSo we create a tick function to execute the gameLoop inside the ref. This way, setInterval does not get stuck\nwith a statically","–","scoped gameLoop!"),(0,o.mdx)("p",null,"The real best solution, though, is to not use any React related functionalities. We can just tie the game state\nto the component","'","s scope and let setInterval call gameLoop that will be responsible to read the game state and\nupdate the canvas. Admittedly when I started this little project, I couldn","'","t see this possibility, but at\nleast I exercised all of the React muscles there are. Pretty cool if you ask me."))}c.isMDXComponent=!0},3366:function(e,t,a){function n(e,t){if(null==e)return{};var a,n,o={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}a.d(t,{Z:function(){return n}})}}]);
//# sourceMappingURL=component---src-pages-lessons-from-the-snake-game-lessons-from-the-snake-game-mdx-ed0c7c3a539362434497.js.map